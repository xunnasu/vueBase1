<!--
 * @Author: your name
 * @Date: 2020-09-06 10:59:01
 * @LastEditTime: 2020-09-06 14:31:39
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \vueBase1\this指向.html
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>this指向问题</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <style></style>
  </head>
  <style>

  </style>
  <body>
    <div id="app">
     
    </div>
    <script>
      var app3 = new Vue({
        el: "#app",
        data:{
          
        },
        created(){
          // 1.this指向全局
          function foo(){
            console.log('this :>> ', this);
          }
          foo()
          // 这说明在默认情况下调用一个函数，其执行上下文中的this都是指向window

          //2.通过对象调用方法
          var obj1 ={
            name:'su',
            foo2(){
              console.log('通过对象调用方法:>> ', this.name);
            }
          }
          obj1.foo2()
          // 这里的this指向的是对象obj，因为你调用这个foo2是通过obj.foo2()执行的，
          // 那自然指向就是对象obj，这里再次强调一点，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁!

          //3.函数执行上下文中的 this(这里可以通过call，apply,bind方法调用)
          // call方法(this指向传入的对象,若不传值,this仍然指向window)
          var obj2 = {
            name:"nana"
          }
          function foo2(){
            console.log('函数执行上下文中的this :>> ', this);
          }
          // foo2()
          foo2.call(obj2)
          // 3.1 apply方法


      //     function foo() {
      //   console.log(this.a) //1
      // }
      // var a = 1
      // foo()

      // const obj = {
      //   a: 2,
      //   foo: foo
      // }
      // obj.foo()

      // const c = new foo()
      // console.log('c :>> ', c); //foo(){}

      // var obj1 = {
      //    num: 13,
      //    fn: function() {
      //      console.log(this.num);
      //    }
      //  };
      // var obj2 = {
      //   num: 23,
      //   fn: function() {
      //     console.log(this.num);
      //   }
      // };
      // obj1.fn();
      // obj1.fn.call(obj2);

      // function foo(){
      //    console.log(this.a);
      // }
      // function Foo(fn){
      //    fn();
      // }
      // var obj={
      //    a:2,
      //    foo:foo
      // }
      // var a=1;
      // Foo(obj.foo)//输出1
      // 'use strict'
      // function fun(){
      //   console.log(this)  //这里this就会指向全局上下文中的this, 输出object
      // }
      // function foo(fn){
      //   // window.fff = fn
      //   //参数传递其实就是一个隐式的赋值，
      //   //当作普通函数调用,所以会找到全局上下文中name为object,即输出object,其实符合“独立函数调用”规则
      //   fn()
      //   // window.fff()

      // }

        }
      });
    </script>
  </body>
</html>
